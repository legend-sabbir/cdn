{"version":3,"file":"lua-service.js","mappings":"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","sources":["webpack://ace-linters/webpack/universalModuleDefinition","webpack://ace-linters/../../node_modules/luaparse/luaparse.js","webpack://ace-linters/./services/base-service.ts","webpack://ace-linters/./services/lua/lua-service.ts","webpack://ace-linters/./utils.ts","webpack://ace-linters/../../node_modules/vscode-languageserver-textdocument/lib/esm/main.js","webpack://ace-linters/webpack/bootstrap","webpack://ace-linters/webpack/runtime/define property getters","webpack://ace-linters/webpack/runtime/global","webpack://ace-linters/webpack/runtime/hasOwnProperty shorthand","webpack://ace-linters/webpack/runtime/make namespace object","webpack://ace-linters/webpack/runtime/node module decorator","webpack://ace-linters/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, () => {\nreturn ","/* global exports:true, module:true, require:true, define:true, global:true */\n\n(function (root, name, factory) {\n  'use strict';\n\n  // Used to determine if values are of the language type `Object`\n  var objectTypes = {\n        'function': true\n      , 'object': true\n    }\n    // Detect free variable `exports`\n    , freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports\n    // Detect free variable `module`\n    , freeModule = objectTypes[typeof module] && module && !module.nodeType && module\n    // Detect free variable `global`, from Node.js or Browserified code, and\n    // use it as `window`\n    , freeGlobal = freeExports && freeModule && typeof global === 'object' && global\n    // Detect the popular CommonJS extension `module.exports`\n    , moduleExports = freeModule && freeModule.exports === freeExports && freeExports;\n\n  /* istanbul ignore else */\n  if (freeGlobal && (freeGlobal.global === freeGlobal ||\n                     /* istanbul ignore next */ freeGlobal.window === freeGlobal ||\n                     /* istanbul ignore next */ freeGlobal.self === freeGlobal)) {\n    root = freeGlobal;\n  }\n\n  // Some AMD build optimizers, like r.js, check for specific condition\n  // patterns like the following:\n  /* istanbul ignore if */\n  if (typeof define === 'function' &&\n      /* istanbul ignore next */ typeof define.amd === 'object' &&\n      /* istanbul ignore next */ define.amd) {\n    // defined as an anonymous module.\n    define(['exports'], factory);\n    // In case the source has been processed and wrapped in a define module use\n    // the supplied `exports` object.\n    if (freeExports && moduleExports) factory(freeModule.exports);\n  }\n  // check for `exports` after `define` in case a build optimizer adds an\n  // `exports` object\n  else /* istanbul ignore else */ if (freeExports && freeModule) {\n    // in Node.js or RingoJS v0.8.0+\n    /* istanbul ignore else */\n    if (moduleExports) factory(freeModule.exports);\n    // in RingoJS v0.7.0-\n    else factory(freeExports);\n  }\n  // in a browser or Rhino\n  else {\n    factory((root[name] = {}));\n  }\n}(this, 'luaparse', function (exports) {\n  'use strict';\n\n  exports.version = \"0.3.1\";\n\n  var input, options, length, features, encodingMode;\n\n  // Options can be set either globally on the parser object through\n  // defaultOptions, or during the parse call.\n  var defaultOptions = exports.defaultOptions = {\n    // Explicitly tell the parser when the input ends.\n      wait: false\n    // Store comments as an array in the chunk object.\n    , comments: true\n    // Track identifier scopes by adding an isLocal attribute to each\n    // identifier-node.\n    , scope: false\n    // Store location information on each syntax node as\n    // `loc: { start: { line, column }, end: { line, column } }`.\n    , locations: false\n    // Store the start and end character locations on each syntax node as\n    // `range: [start, end]`.\n    , ranges: false\n    // A callback which will be invoked when a syntax node has been completed.\n    // The node which has been created will be passed as the only parameter.\n    , onCreateNode: null\n    // A callback which will be invoked when a new scope is created.\n    , onCreateScope: null\n    // A callback which will be invoked when the current scope is destroyed.\n    , onDestroyScope: null\n    // A callback which will be invoked when a local variable is declared in the current scope.\n    // The variable's name will be passed as the only parameter\n    , onLocalDeclaration: null\n    // The version of Lua targeted by the parser (string; allowed values are\n    // '5.1', '5.2', '5.3').\n    , luaVersion: '5.1'\n    // Encoding mode: how to interpret code units higher than U+007F in input\n    , encodingMode: 'none'\n  };\n\n  function encodeUTF8(codepoint, highMask) {\n    highMask = highMask || 0;\n\n    if (codepoint < 0x80) {\n      return String.fromCharCode(codepoint);\n    } else if (codepoint < 0x800) {\n      return String.fromCharCode(\n        highMask | 0xc0 |  (codepoint >>  6)        ,\n        highMask | 0x80 | ( codepoint        & 0x3f)\n      );\n    } else if (codepoint < 0x10000) {\n      return String.fromCharCode(\n        highMask | 0xe0 |  (codepoint >> 12)        ,\n        highMask | 0x80 | ((codepoint >>  6) & 0x3f),\n        highMask | 0x80 | ( codepoint        & 0x3f)\n      );\n    } else /* istanbul ignore else */ if (codepoint < 0x110000) {\n      return String.fromCharCode(\n        highMask | 0xf0 |  (codepoint >> 18)        ,\n        highMask | 0x80 | ((codepoint >> 12) & 0x3f),\n        highMask | 0x80 | ((codepoint >>  6) & 0x3f),\n        highMask | 0x80 | ( codepoint        & 0x3f)\n      );\n    } else {\n      // TODO: Lua 5.4 allows up to six-byte sequences, as in UTF-8:1993\n      return null;\n    }\n  }\n\n  function toHex(num, digits) {\n    var result = num.toString(16);\n    while (result.length < digits)\n      result = '0' + result;\n    return result;\n  }\n\n  function checkChars(rx) {\n    return function (s) {\n      var m = rx.exec(s);\n      if (!m)\n        return s;\n      raise(null, errors.invalidCodeUnit, toHex(m[0].charCodeAt(0), 4).toUpperCase());\n    };\n  }\n\n  var encodingModes = {\n    // `pseudo-latin1` encoding mode: assume the input was decoded with the latin1 encoding\n    // WARNING: latin1 does **NOT** mean cp1252 here like in the bone-headed WHATWG standard;\n    // it means true ISO/IEC 8859-1 identity-mapped to Basic Latin and Latin-1 Supplement blocks\n    'pseudo-latin1': {\n      fixup: checkChars(/[^\\x00-\\xff]/),\n      encodeByte: function (value) {\n        if (value === null)\n          return '';\n        return String.fromCharCode(value);\n      },\n      encodeUTF8: function (codepoint) {\n        return encodeUTF8(codepoint);\n      },\n    },\n\n    // `x-user-defined` encoding mode: assume the input was decoded with the WHATWG `x-user-defined` encoding\n    'x-user-defined': {\n      fixup: checkChars(/[^\\x00-\\x7f\\uf780-\\uf7ff]/),\n      encodeByte: function (value) {\n        if (value === null)\n          return '';\n        if (value >= 0x80)\n          return String.fromCharCode(value | 0xf700);\n        return String.fromCharCode(value);\n      },\n      encodeUTF8: function (codepoint) {\n        return encodeUTF8(codepoint, 0xf700);\n      }\n    },\n\n    // `none` encoding mode: disregard intrepretation of string literals, leave identifiers as-is\n    'none': {\n      discardStrings: true,\n      fixup: function (s) {\n        return s;\n      },\n      encodeByte: function (value) {\n        return '';\n      },\n      encodeUTF8: function (codepoint) {\n        return '';\n      }\n    }\n  };\n\n  // The available tokens expressed as enum flags so they can be checked with\n  // bitwise operations.\n\n  var EOF = 1, StringLiteral = 2, Keyword = 4, Identifier = 8\n    , NumericLiteral = 16, Punctuator = 32, BooleanLiteral = 64\n    , NilLiteral = 128, VarargLiteral = 256;\n\n  exports.tokenTypes = { EOF: EOF, StringLiteral: StringLiteral\n    , Keyword: Keyword, Identifier: Identifier, NumericLiteral: NumericLiteral\n    , Punctuator: Punctuator, BooleanLiteral: BooleanLiteral\n    , NilLiteral: NilLiteral, VarargLiteral: VarargLiteral\n  };\n\n  // As this parser is a bit different from luas own, the error messages\n  // will be different in some situations.\n\n  var errors = exports.errors = {\n      unexpected: 'unexpected %1 \\'%2\\' near \\'%3\\''\n    , unexpectedEOF: 'unexpected symbol near \\'<eof>\\''\n    , expected: '\\'%1\\' expected near \\'%2\\''\n    , expectedToken: '%1 expected near \\'%2\\''\n    , unfinishedString: 'unfinished string near \\'%1\\''\n    , malformedNumber: 'malformed number near \\'%1\\''\n    , decimalEscapeTooLarge: 'decimal escape too large near \\'%1\\''\n    , invalidEscape: 'invalid escape sequence near \\'%1\\''\n    , hexadecimalDigitExpected: 'hexadecimal digit expected near \\'%1\\''\n    , braceExpected: 'missing \\'%1\\' near \\'%2\\''\n    , tooLargeCodepoint: 'UTF-8 value too large near \\'%1\\''\n    , unfinishedLongString: 'unfinished long string (starting at line %1) near \\'%2\\''\n    , unfinishedLongComment: 'unfinished long comment (starting at line %1) near \\'%2\\''\n    , ambiguousSyntax: 'ambiguous syntax (function call x new statement) near \\'%1\\''\n    , noLoopToBreak: 'no loop to break near \\'%1\\''\n    , labelAlreadyDefined: 'label \\'%1\\' already defined on line %2'\n    , labelNotVisible: 'no visible label \\'%1\\' for <goto>'\n    , gotoJumpInLocalScope: '<goto %1> jumps into the scope of local \\'%2\\''\n    , cannotUseVararg: 'cannot use \\'...\\' outside a vararg function near \\'%1\\''\n    , invalidCodeUnit: 'code unit U+%1 is not allowed in the current encoding mode'\n  };\n\n  // ### Abstract Syntax Tree\n  //\n  // The default AST structure is inspired by the Mozilla Parser API but can\n  // easily be customized by overriding these functions.\n\n  var ast = exports.ast = {\n      labelStatement: function(label) {\n      return {\n          type: 'LabelStatement'\n        , label: label\n      };\n    }\n\n    , breakStatement: function() {\n      return {\n          type: 'BreakStatement'\n      };\n    }\n\n    , gotoStatement: function(label) {\n      return {\n          type: 'GotoStatement'\n        , label: label\n      };\n    }\n\n    , returnStatement: function(args) {\n      return {\n          type: 'ReturnStatement'\n        , 'arguments': args\n      };\n    }\n\n    , ifStatement: function(clauses) {\n      return {\n          type: 'IfStatement'\n        , clauses: clauses\n      };\n    }\n    , ifClause: function(condition, body) {\n      return {\n          type: 'IfClause'\n        , condition: condition\n        , body: body\n      };\n    }\n    , elseifClause: function(condition, body) {\n      return {\n          type: 'ElseifClause'\n        , condition: condition\n        , body: body\n      };\n    }\n    , elseClause: function(body) {\n      return {\n          type: 'ElseClause'\n        , body: body\n      };\n    }\n\n    , whileStatement: function(condition, body) {\n      return {\n          type: 'WhileStatement'\n        , condition: condition\n        , body: body\n      };\n    }\n\n    , doStatement: function(body) {\n      return {\n          type: 'DoStatement'\n        , body: body\n      };\n    }\n\n    , repeatStatement: function(condition, body) {\n      return {\n          type: 'RepeatStatement'\n        , condition: condition\n        , body: body\n      };\n    }\n\n    , localStatement: function(variables, init) {\n      return {\n          type: 'LocalStatement'\n        , variables: variables\n        , init: init\n      };\n    }\n\n    , assignmentStatement: function(variables, init) {\n      return {\n          type: 'AssignmentStatement'\n        , variables: variables\n        , init: init\n      };\n    }\n\n    , callStatement: function(expression) {\n      return {\n          type: 'CallStatement'\n        , expression: expression\n      };\n    }\n\n    , functionStatement: function(identifier, parameters, isLocal, body) {\n      return {\n          type: 'FunctionDeclaration'\n        , identifier: identifier\n        , isLocal: isLocal\n        , parameters: parameters\n        , body: body\n      };\n    }\n\n    , forNumericStatement: function(variable, start, end, step, body) {\n      return {\n          type: 'ForNumericStatement'\n        , variable: variable\n        , start: start\n        , end: end\n        , step: step\n        , body: body\n      };\n    }\n\n    , forGenericStatement: function(variables, iterators, body) {\n      return {\n          type: 'ForGenericStatement'\n        , variables: variables\n        , iterators: iterators\n        , body: body\n      };\n    }\n\n    , chunk: function(body) {\n      return {\n          type: 'Chunk'\n        , body: body\n      };\n    }\n\n    , identifier: function(name) {\n      return {\n          type: 'Identifier'\n        , name: name\n      };\n    }\n\n    , literal: function(type, value, raw) {\n      type = (type === StringLiteral) ? 'StringLiteral'\n        : (type === NumericLiteral) ? 'NumericLiteral'\n        : (type === BooleanLiteral) ? 'BooleanLiteral'\n        : (type === NilLiteral) ? 'NilLiteral'\n        : 'VarargLiteral';\n\n      return {\n          type: type\n        , value: value\n        , raw: raw\n      };\n    }\n\n    , tableKey: function(key, value) {\n      return {\n          type: 'TableKey'\n        , key: key\n        , value: value\n      };\n    }\n    , tableKeyString: function(key, value) {\n      return {\n          type: 'TableKeyString'\n        , key: key\n        , value: value\n      };\n    }\n    , tableValue: function(value) {\n      return {\n          type: 'TableValue'\n        , value: value\n      };\n    }\n\n\n    , tableConstructorExpression: function(fields) {\n      return {\n          type: 'TableConstructorExpression'\n        , fields: fields\n      };\n    }\n    , binaryExpression: function(operator, left, right) {\n      var type = ('and' === operator || 'or' === operator) ?\n        'LogicalExpression' :\n        'BinaryExpression';\n\n      return {\n          type: type\n        , operator: operator\n        , left: left\n        , right: right\n      };\n    }\n    , unaryExpression: function(operator, argument) {\n      return {\n          type: 'UnaryExpression'\n        , operator: operator\n        , argument: argument\n      };\n    }\n    , memberExpression: function(base, indexer, identifier) {\n      return {\n          type: 'MemberExpression'\n        , indexer: indexer\n        , identifier: identifier\n        , base: base\n      };\n    }\n\n    , indexExpression: function(base, index) {\n      return {\n          type: 'IndexExpression'\n        , base: base\n        , index: index\n      };\n    }\n\n    , callExpression: function(base, args) {\n      return {\n          type: 'CallExpression'\n        , base: base\n        , 'arguments': args\n      };\n    }\n\n    , tableCallExpression: function(base, args) {\n      return {\n          type: 'TableCallExpression'\n        , base: base\n        , 'arguments': args\n      };\n    }\n\n    , stringCallExpression: function(base, argument) {\n      return {\n          type: 'StringCallExpression'\n        , base: base\n        , argument: argument\n      };\n    }\n\n    , comment: function(value, raw) {\n      return {\n          type: 'Comment'\n        , value: value\n        , raw: raw\n      };\n    }\n  };\n\n  // Wrap up the node object.\n\n  function finishNode(node) {\n    // Pop a `Marker` off the location-array and attach its location data.\n    if (trackLocations) {\n      var location = locations.pop();\n      location.complete();\n      location.bless(node);\n    }\n    if (options.onCreateNode) options.onCreateNode(node);\n    return node;\n  }\n\n\n  // Helpers\n  // -------\n\n  var slice = Array.prototype.slice\n    , toString = Object.prototype.toString\n    ;\n\n  var indexOf = /* istanbul ignore next */ function (array, element) {\n    for (var i = 0, length = array.length; i < length; ++i) {\n      if (array[i] === element) return i;\n    }\n    return -1;\n  };\n\n  /* istanbul ignore else */\n  if (Array.prototype.indexOf)\n    indexOf = function (array, element) {\n      return array.indexOf(element);\n    };\n\n  // Iterate through an array of objects and return the index of an object\n  // with a matching property.\n\n  function indexOfObject(array, property, element) {\n    for (var i = 0, length = array.length; i < length; ++i) {\n      if (array[i][property] === element) return i;\n    }\n    return -1;\n  }\n\n  // A sprintf implementation using %index (beginning at 1) to input\n  // arguments in the format string.\n  //\n  // Example:\n  //\n  //     // Unexpected function in token\n  //     sprintf('Unexpected %2 in %1.', 'token', 'function');\n\n  function sprintf(format) {\n    var args = slice.call(arguments, 1);\n    format = format.replace(/%(\\d)/g, function (match, index) {\n      return '' + args[index - 1] || /* istanbul ignore next */ '';\n    });\n    return format;\n  }\n\n  // Polyfill for `Object.assign`.\n\n  var assign = /* istanbul ignore next */ function (dest) {\n    var args = slice.call(arguments, 1)\n      , src, prop;\n\n    for (var i = 0, length = args.length; i < length; ++i) {\n      src = args[i];\n      for (prop in src)\n        /* istanbul ignore else */\n        if (Object.prototype.hasOwnProperty.call(src, prop)) {\n          dest[prop] = src[prop];\n        }\n    }\n\n    return dest;\n  };\n\n  /* istanbul ignore else */\n  if (Object.assign)\n    assign = Object.assign;\n\n  // ### Error functions\n\n  exports.SyntaxError = SyntaxError;\n\n  // XXX: Eliminate this function and change the error type to be different from SyntaxError.\n  // This will unfortunately be a breaking change, because some downstream users depend\n  // on the error thrown being an instance of SyntaxError. For example, the Ace editor:\n  // <https://github.com/ajaxorg/ace/blob/4c7e5eb3f5d5ca9434847be51834a4e41661b852/lib/ace/mode/lua_worker.js#L55>\n\n  function fixupError(e) {\n    /* istanbul ignore if */\n    if (!Object.create)\n      return e;\n    return Object.create(e, {\n      'line': { 'writable': true, value: e.line },\n      'index': { 'writable': true, value: e.index },\n      'column': { 'writable': true, value: e.column }\n    });\n  }\n\n  // #### Raise an exception.\n  //\n  // Raise an exception by passing a token, a string format and its paramters.\n  //\n  // The passed tokens location will automatically be added to the error\n  // message if it exists, if not it will default to the lexers current\n  // position.\n  //\n  // Example:\n  //\n  //     // [1:0] expected [ near (\n  //     raise(token, \"expected %1 near %2\", '[', token.value);\n\n  function raise(token) {\n    var message = sprintf.apply(null, slice.call(arguments, 1))\n      , error, col;\n\n    if (token === null || typeof token.line === 'undefined') {\n      col = index - lineStart + 1;\n      error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', line, col, message)));\n      error.index = index;\n      error.line = line;\n      error.column = col;\n    } else {\n      col = token.range[0] - token.lineStart;\n      error = fixupError(new SyntaxError(sprintf('[%1:%2] %3', token.line, col, message)));\n      error.line = token.line;\n      error.index = token.range[0];\n      error.column = col;\n    }\n    throw error;\n  }\n\n  function tokenValue(token) {\n    var raw = input.slice(token.range[0], token.range[1]);\n    if (raw)\n      return raw;\n    return token.value;\n  }\n\n  // #### Raise an unexpected token error.\n  //\n  // Example:\n  //\n  //     // expected <name> near '0'\n  //     raiseUnexpectedToken('<name>', token);\n\n  function raiseUnexpectedToken(type, token) {\n    raise(token, errors.expectedToken, type, tokenValue(token));\n  }\n\n  // #### Raise a general unexpected error\n  //\n  // Usage should pass either a token object or a symbol string which was\n  // expected. We can also specify a nearby token such as <eof>, this will\n  // default to the currently active token.\n  //\n  // Example:\n  //\n  //     // Unexpected symbol 'end' near '<eof>'\n  //     unexpected(token);\n  //\n  // If there's no token in the buffer it means we have reached <eof>.\n\n  function unexpected(found) {\n    var near = tokenValue(lookahead);\n    if ('undefined' !== typeof found.type) {\n      var type;\n      switch (found.type) {\n        case StringLiteral:   type = 'string';      break;\n        case Keyword:         type = 'keyword';     break;\n        case Identifier:      type = 'identifier';  break;\n        case NumericLiteral:  type = 'number';      break;\n        case Punctuator:      type = 'symbol';      break;\n        case BooleanLiteral:  type = 'boolean';     break;\n        case NilLiteral:\n          return raise(found, errors.unexpected, 'symbol', 'nil', near);\n        case EOF:\n          return raise(found, errors.unexpectedEOF);\n      }\n      return raise(found, errors.unexpected, type, tokenValue(found), near);\n    }\n    return raise(found, errors.unexpected, 'symbol', found, near);\n  }\n\n  // Lexer\n  // -----\n  //\n  // The lexer, or the tokenizer reads the input string character by character\n  // and derives a token left-right. To be as efficient as possible the lexer\n  // prioritizes the common cases such as identifiers. It also works with\n  // character codes instead of characters as string comparisons was the\n  // biggest bottleneck of the parser.\n  //\n  // If `options.comments` is enabled, all comments encountered will be stored\n  // in an array which later will be appended to the chunk object. If disabled,\n  // they will simply be disregarded.\n  //\n  // When the lexer has derived a valid token, it will be returned as an object\n  // containing its value and as well as its position in the input string (this\n  // is always enabled to provide proper debug messages).\n  //\n  // `lex()` starts lexing and returns the following token in the stream.\n\n  var index\n    , token\n    , previousToken\n    , lookahead\n    , comments\n    , tokenStart\n    , line\n    , lineStart;\n\n  exports.lex = lex;\n\n  function lex() {\n    skipWhiteSpace();\n\n    // Skip comments beginning with --\n    while (45 === input.charCodeAt(index) &&\n           45 === input.charCodeAt(index + 1)) {\n      scanComment();\n      skipWhiteSpace();\n    }\n    if (index >= length) return {\n        type : EOF\n      , value: '<eof>'\n      , line: line\n      , lineStart: lineStart\n      , range: [index, index]\n    };\n\n    var charCode = input.charCodeAt(index)\n      , next = input.charCodeAt(index + 1);\n\n    // Memorize the range index where the token begins.\n    tokenStart = index;\n    if (isIdentifierStart(charCode)) return scanIdentifierOrKeyword();\n\n    switch (charCode) {\n      case 39: case 34: // '\"\n        return scanStringLiteral();\n\n      case 48: case 49: case 50: case 51: case 52: case 53:\n      case 54: case 55: case 56: case 57: // 0-9\n        return scanNumericLiteral();\n\n      case 46: // .\n        // If the dot is followed by a digit it's a float.\n        if (isDecDigit(next)) return scanNumericLiteral();\n        if (46 === next) {\n          if (46 === input.charCodeAt(index + 2)) return scanVarargLiteral();\n          return scanPunctuator('..');\n        }\n        return scanPunctuator('.');\n\n      case 61: // =\n        if (61 === next) return scanPunctuator('==');\n        return scanPunctuator('=');\n\n      case 62: // >\n        if (features.bitwiseOperators)\n          if (62 === next) return scanPunctuator('>>');\n        if (61 === next) return scanPunctuator('>=');\n        return scanPunctuator('>');\n\n      case 60: // <\n        if (features.bitwiseOperators)\n          if (60 === next) return scanPunctuator('<<');\n        if (61 === next) return scanPunctuator('<=');\n        return scanPunctuator('<');\n\n      case 126: // ~\n        if (61 === next) return scanPunctuator('~=');\n        if (!features.bitwiseOperators)\n          break;\n        return scanPunctuator('~');\n\n      case 58: // :\n        if (features.labels)\n          if (58 === next) return scanPunctuator('::');\n        return scanPunctuator(':');\n\n      case 91: // [\n        // Check for a multiline string, they begin with [= or [[\n        if (91 === next || 61 === next) return scanLongStringLiteral();\n        return scanPunctuator('[');\n\n      case 47: // /\n        // Check for integer division op (//)\n        if (features.integerDivision)\n          if (47 === next) return scanPunctuator('//');\n        return scanPunctuator('/');\n\n      case 38: case 124: // & |\n        if (!features.bitwiseOperators)\n          break;\n\n        /* fall through */\n      case 42: case 94: case 37: case 44: case 123: case 125:\n      case 93: case 40: case 41: case 59: case 35: case 45:\n      case 43: // * ^ % , { } ] ( ) ; # - +\n        return scanPunctuator(input.charAt(index));\n    }\n\n    return unexpected(input.charAt(index));\n  }\n\n  // Whitespace has no semantic meaning in lua so simply skip ahead while\n  // tracking the encounted newlines. Any kind of eol sequence is counted as a\n  // single line.\n\n  function consumeEOL() {\n    var charCode = input.charCodeAt(index)\n      , peekCharCode = input.charCodeAt(index + 1);\n\n    if (isLineTerminator(charCode)) {\n      // Count \\n\\r and \\r\\n as one newline.\n      if (10 === charCode && 13 === peekCharCode) ++index;\n      if (13 === charCode && 10 === peekCharCode) ++index;\n      ++line;\n      lineStart = ++index;\n\n      return true;\n    }\n    return false;\n  }\n\n  function skipWhiteSpace() {\n    while (index < length) {\n      var charCode = input.charCodeAt(index);\n      if (isWhiteSpace(charCode)) {\n        ++index;\n      } else if (!consumeEOL()) {\n        break;\n      }\n    }\n  }\n\n  // Identifiers, keywords, booleans and nil all look the same syntax wise. We\n  // simply go through them one by one and defaulting to an identifier if no\n  // previous case matched.\n\n  function scanIdentifierOrKeyword() {\n    var value, type;\n\n    // Slicing the input string is prefered before string concatenation in a\n    // loop for performance reasons.\n    while (isIdentifierPart(input.charCodeAt(++index)));\n    value = encodingMode.fixup(input.slice(tokenStart, index));\n\n    // Decide on the token type and possibly cast the value.\n    if (isKeyword(value)) {\n      type = Keyword;\n    } else if ('true' === value || 'false' === value) {\n      type = BooleanLiteral;\n      value = ('true' === value);\n    } else if ('nil' === value) {\n      type = NilLiteral;\n      value = null;\n    } else {\n      type = Identifier;\n    }\n\n    return {\n        type: type\n      , value: value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Once a punctuator reaches this function it should already have been\n  // validated so we simply return it as a token.\n\n  function scanPunctuator(value) {\n    index += value.length;\n    return {\n        type: Punctuator\n      , value: value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // A vararg literal consists of three dots.\n\n  function scanVarargLiteral() {\n    index += 3;\n    return {\n        type: VarargLiteral\n      , value: '...'\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Find the string literal by matching the delimiter marks used.\n\n  function scanStringLiteral() {\n    var delimiter = input.charCodeAt(index++)\n      , beginLine = line\n      , beginLineStart = lineStart\n      , stringStart = index\n      , string = encodingMode.discardStrings ? null : ''\n      , charCode;\n\n    for (;;) {\n      charCode = input.charCodeAt(index++);\n      if (delimiter === charCode) break;\n      // EOF or `\\n` terminates a string literal. If we haven't found the\n      // ending delimiter by now, raise an exception.\n      if (index > length || isLineTerminator(charCode)) {\n        string += input.slice(stringStart, index - 1);\n        raise(null, errors.unfinishedString, input.slice(tokenStart, index - 1));\n      }\n      if (92 === charCode) { // backslash\n        if (!encodingMode.discardStrings) {\n          var beforeEscape = input.slice(stringStart, index - 1);\n          string += encodingMode.fixup(beforeEscape);\n        }\n        var escapeValue = readEscapeSequence();\n        if (!encodingMode.discardStrings)\n          string += escapeValue;\n        stringStart = index;\n      }\n    }\n    if (!encodingMode.discardStrings) {\n      string += encodingMode.encodeByte(null);\n      string += encodingMode.fixup(input.slice(stringStart, index - 1));\n    }\n\n    return {\n        type: StringLiteral\n      , value: string\n      , line: beginLine\n      , lineStart: beginLineStart\n      , lastLine: line\n      , lastLineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Expect a multiline string literal and return it as a regular string\n  // literal, if it doesn't validate into a valid multiline string, throw an\n  // exception.\n\n  function scanLongStringLiteral() {\n    var beginLine = line\n      , beginLineStart = lineStart\n      , string = readLongString(false);\n    // Fail if it's not a multiline literal.\n    if (false === string) raise(token, errors.expected, '[', tokenValue(token));\n\n    return {\n        type: StringLiteral\n      , value: encodingMode.discardStrings ? null : encodingMode.fixup(string)\n      , line: beginLine\n      , lineStart: beginLineStart\n      , lastLine: line\n      , lastLineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  // Numeric literals will be returned as floating-point numbers instead of\n  // strings. The raw value should be retrieved from slicing the input string\n  // later on in the process.\n  //\n  // If a hexadecimal number is encountered, it will be converted.\n\n  function scanNumericLiteral() {\n    var character = input.charAt(index)\n      , next = input.charAt(index + 1);\n\n    var literal = ('0' === character && 'xX'.indexOf(next || null) >= 0) ?\n      readHexLiteral() : readDecLiteral();\n\n    var foundImaginaryUnit = readImaginaryUnitSuffix()\n      , foundInt64Suffix = readInt64Suffix();\n\n    if (foundInt64Suffix && (foundImaginaryUnit || literal.hasFractionPart)) {\n      raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n    }\n\n    return {\n        type: NumericLiteral\n      , value: literal.value\n      , line: line\n      , lineStart: lineStart\n      , range: [tokenStart, index]\n    };\n  }\n\n  function readImaginaryUnitSuffix() {\n    if (!features.imaginaryNumbers) return;\n\n    // Imaginary unit number suffix is optional.\n    // See http://luajit.org/ext_ffi_api.html#literals\n    if ('iI'.indexOf(input.charAt(index) || null) >= 0) {\n      ++index;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function readInt64Suffix() {\n    if (!features.integerSuffixes) return;\n\n    // Int64/uint64 number suffix is optional.\n    // See http://luajit.org/ext_ffi_api.html#literals\n\n    if ('uU'.indexOf(input.charAt(index) || null) >= 0) {\n      ++index;\n      if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n        ++index;\n        if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n          ++index;\n          return 'ULL';\n        } else {\n          // UL but no L\n          raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n        }\n      } else {\n        // U but no L\n        raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n      }\n    } else if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n        ++index;\n        if ('lL'.indexOf(input.charAt(index) || null) >= 0) {\n          ++index;\n          return 'LL';\n        } else {\n          // First L but no second L\n          raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n        }\n    }\n  }\n\n  // Lua hexadecimals have an optional fraction part and an optional binary\n  // exoponent part. These are not included in JavaScript so we will compute\n  // all three parts separately and then sum them up at the end of the function\n  // with the following algorithm.\n  //\n  //     Digit := toDec(digit)\n  //     Fraction := toDec(fraction) / 16 ^ fractionCount\n  //     BinaryExp := 2 ^ binaryExp\n  //     Number := ( Digit + Fraction ) * BinaryExp\n\n  function readHexLiteral() {\n    var fraction = 0 // defaults to 0 as it gets summed\n      , binaryExponent = 1 // defaults to 1 as it gets multiplied\n      , binarySign = 1 // positive\n      , digit, fractionStart, exponentStart, digitStart;\n\n    digitStart = index += 2; // Skip 0x part\n\n    // A minimum of one hex digit is required.\n    if (!isHexDigit(input.charCodeAt(index)))\n      raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n\n    while (isHexDigit(input.charCodeAt(index))) ++index;\n    // Convert the hexadecimal digit to base 10.\n    digit = parseInt(input.slice(digitStart, index), 16);\n\n    // Fraction part is optional.\n    var foundFraction = false;\n    if ('.' === input.charAt(index)) {\n      foundFraction = true;\n      fractionStart = ++index;\n\n      while (isHexDigit(input.charCodeAt(index))) ++index;\n      fraction = input.slice(fractionStart, index);\n\n      // Empty fraction parts should default to 0, others should be converted\n      // 0.x form so we can use summation at the end.\n      fraction = (fractionStart === index) ? 0\n        : parseInt(fraction, 16) / Math.pow(16, index - fractionStart);\n    }\n\n    // Binary exponents are optional\n    var foundBinaryExponent = false;\n    if ('pP'.indexOf(input.charAt(index) || null) >= 0) {\n      foundBinaryExponent = true;\n      ++index;\n\n      // Sign part is optional and defaults to 1 (positive).\n      if ('+-'.indexOf(input.charAt(index) || null) >= 0)\n        binarySign = ('+' === input.charAt(index++)) ? 1 : -1;\n\n      exponentStart = index;\n\n      // The binary exponent sign requires a decimal digit.\n      if (!isDecDigit(input.charCodeAt(index)))\n        raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n\n      while (isDecDigit(input.charCodeAt(index))) ++index;\n      binaryExponent = input.slice(exponentStart, index);\n\n      // Calculate the binary exponent of the number.\n      binaryExponent = Math.pow(2, binaryExponent * binarySign);\n    }\n\n    return {\n      value: (digit + fraction) * binaryExponent,\n      hasFractionPart: foundFraction || foundBinaryExponent\n    };\n  }\n\n  // Decimal numbers are exactly the same in Lua and in JavaScript, because of\n  // this we check where the token ends and then parse it with native\n  // functions.\n\n  function readDecLiteral() {\n    while (isDecDigit(input.charCodeAt(index))) ++index;\n    // Fraction part is optional\n    var foundFraction = false;\n    if ('.' === input.charAt(index)) {\n      foundFraction = true;\n      ++index;\n      // Fraction part defaults to 0\n      while (isDecDigit(input.charCodeAt(index))) ++index;\n    }\n\n    // Exponent part is optional.\n    var foundExponent = false;\n    if ('eE'.indexOf(input.charAt(index) || null) >= 0) {\n      foundExponent = true;\n      ++index;\n      // Sign part is optional.\n      if ('+-'.indexOf(input.charAt(index) || null) >= 0) ++index;\n      // An exponent is required to contain at least one decimal digit.\n      if (!isDecDigit(input.charCodeAt(index)))\n        raise(null, errors.malformedNumber, input.slice(tokenStart, index));\n\n      while (isDecDigit(input.charCodeAt(index))) ++index;\n    }\n\n    return {\n      value: parseFloat(input.slice(tokenStart, index)),\n      hasFractionPart: foundFraction || foundExponent\n    };\n  }\n\n  function readUnicodeEscapeSequence() {\n    var sequenceStart = index++;\n\n    if (input.charAt(index++) !== '{')\n      raise(null, errors.braceExpected, '{', '\\\\' + input.slice(sequenceStart, index));\n    if (!isHexDigit(input.charCodeAt(index)))\n      raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index));\n\n    while (input.charCodeAt(index) === 0x30) ++index;\n    var escStart = index;\n\n    while (isHexDigit(input.charCodeAt(index))) {\n      ++index;\n      if (index - escStart > 6)\n        raise(null, errors.tooLargeCodepoint, '\\\\' + input.slice(sequenceStart, index));\n    }\n\n    var b = input.charAt(index++);\n    if (b !== '}') {\n      if ((b === '\"') || (b === \"'\"))\n        raise(null, errors.braceExpected, '}', '\\\\' + input.slice(sequenceStart, index--));\n      else\n        raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index));\n    }\n\n    var codepoint = parseInt(input.slice(escStart, index - 1) || '0', 16);\n    var frag = '\\\\' + input.slice(sequenceStart, index);\n\n    if (codepoint > 0x10ffff) {\n      raise(null, errors.tooLargeCodepoint, frag);\n    }\n\n    return encodingMode.encodeUTF8(codepoint, frag);\n  }\n\n  // Translate escape sequences to the actual characters.\n  function readEscapeSequence() {\n    var sequenceStart = index;\n    switch (input.charAt(index)) {\n      // Lua allow the following escape sequences.\n      case 'a': ++index; return '\\x07';\n      case 'n': ++index; return '\\n';\n      case 'r': ++index; return '\\r';\n      case 't': ++index; return '\\t';\n      case 'v': ++index; return '\\x0b';\n      case 'b': ++index; return '\\b';\n      case 'f': ++index; return '\\f';\n\n      // Backslash at the end of the line. We treat all line endings as equivalent,\n      // and as representing the [LF] character (code 10). Lua 5.1 through 5.3\n      // have been verified to behave the same way.\n      case '\\r':\n      case '\\n':\n        consumeEOL();\n        return '\\n';\n\n      case '0': case '1': case '2': case '3': case '4':\n      case '5': case '6': case '7': case '8': case '9':\n        // \\ddd, where ddd is a sequence of up to three decimal digits.\n        while (isDecDigit(input.charCodeAt(index)) && index - sequenceStart < 3) ++index;\n\n        var frag = input.slice(sequenceStart, index);\n        var ddd = parseInt(frag, 10);\n        if (ddd > 255) {\n          raise(null, errors.decimalEscapeTooLarge, '\\\\' + ddd);\n        }\n        return encodingMode.encodeByte(ddd, '\\\\' + frag);\n\n      case 'z':\n        if (features.skipWhitespaceEscape) {\n          ++index;\n          skipWhiteSpace();\n          return '';\n        }\n        break;\n\n      case 'x':\n        if (features.hexEscapes) {\n          // \\xXX, where XX is a sequence of exactly two hexadecimal digits\n          if (isHexDigit(input.charCodeAt(index + 1)) &&\n              isHexDigit(input.charCodeAt(index + 2))) {\n            index += 3;\n            return encodingMode.encodeByte(parseInt(input.slice(sequenceStart + 1, index), 16), '\\\\' + input.slice(sequenceStart, index));\n          }\n          raise(null, errors.hexadecimalDigitExpected, '\\\\' + input.slice(sequenceStart, index + 2));\n        }\n        break;\n\n      case 'u':\n        if (features.unicodeEscapes)\n          return readUnicodeEscapeSequence();\n        break;\n\n      case '\\\\': case '\"': case \"'\":\n        return input.charAt(index++);\n    }\n\n    if (features.strictEscapes)\n      raise(null, errors.invalidEscape, '\\\\' + input.slice(sequenceStart, index + 1));\n    return input.charAt(index++);\n  }\n\n  // Comments begin with -- after which it will be decided if they are\n  // multiline comments or not.\n  //\n  // The multiline functionality works the exact same way as with string\n  // literals so we reuse the functionality.\n\n  function scanComment() {\n    tokenStart = index;\n    index += 2; // --\n\n    var character = input.charAt(index)\n      , content = ''\n      , isLong = false\n      , commentStart = index\n      , lineStartComment = lineStart\n      , lineComment = line;\n\n    if ('[' === character) {\n      content = readLongString(true);\n      // This wasn't a multiline comment after all.\n      if (false === content) content = character;\n      else isLong = true;\n    }\n    // Scan until next line as long as it's not a multiline comment.\n    if (!isLong) {\n      while (index < length) {\n        if (isLineTerminator(input.charCodeAt(index))) break;\n        ++index;\n      }\n      if (options.comments) content = input.slice(commentStart, index);\n    }\n\n    if (options.comments) {\n      var node = ast.comment(content, input.slice(tokenStart, index));\n\n      // `Marker`s depend on tokens available in the parser and as comments are\n      // intercepted in the lexer all location data is set manually.\n      if (options.locations) {\n        node.loc = {\n            start: { line: lineComment, column: tokenStart - lineStartComment }\n          , end: { line: line, column: index - lineStart }\n        };\n      }\n      if (options.ranges) {\n        node.range = [tokenStart, index];\n      }\n      if (options.onCreateNode) options.onCreateNode(node);\n      comments.push(node);\n    }\n  }\n\n  // Read a multiline string by calculating the depth of `=` characters and\n  // then appending until an equal depth is found.\n\n  function readLongString(isComment) {\n    var level = 0\n      , content = ''\n      , terminator = false\n      , character, stringStart, firstLine = line;\n\n    ++index; // [\n\n    // Calculate the depth of the comment.\n    while ('=' === input.charAt(index + level)) ++level;\n    // Exit, this is not a long string afterall.\n    if ('[' !== input.charAt(index + level)) return false;\n\n    index += level + 1;\n\n    // If the first character is a newline, ignore it and begin on next line.\n    if (isLineTerminator(input.charCodeAt(index))) consumeEOL();\n\n    stringStart = index;\n    while (index < length) {\n      // To keep track of line numbers run the `consumeEOL()` which increments\n      // its counter.\n      while (isLineTerminator(input.charCodeAt(index))) consumeEOL();\n\n      character = input.charAt(index++);\n\n      // Once the delimiter is found, iterate through the depth count and see\n      // if it matches.\n      if (']' === character) {\n        terminator = true;\n        for (var i = 0; i < level; ++i) {\n          if ('=' !== input.charAt(index + i)) terminator = false;\n        }\n        if (']' !== input.charAt(index + level)) terminator = false;\n      }\n\n      // We reached the end of the multiline string. Get out now.\n      if (terminator) {\n        content += input.slice(stringStart, index - 1);\n        index += level + 1;\n        return content;\n      }\n    }\n\n    raise(null, isComment ?\n                errors.unfinishedLongComment :\n                errors.unfinishedLongString,\n          firstLine, '<eof>');\n  }\n\n  // ## Lex functions and helpers.\n\n  // Read the next token.\n  //\n  // This is actually done by setting the current token to the lookahead and\n  // reading in the new lookahead token.\n\n  function next() {\n    previousToken = token;\n    token = lookahead;\n    lookahead = lex();\n  }\n\n  // Consume a token if its value matches. Once consumed or not, return the\n  // success of the operation.\n\n  function consume(value) {\n    if (value === token.value) {\n      next();\n      return true;\n    }\n    return false;\n  }\n\n  // Expect the next token value to match. If not, throw an exception.\n\n  function expect(value) {\n    if (value === token.value) next();\n    else raise(token, errors.expected, value, tokenValue(token));\n  }\n\n  // ### Validation functions\n\n  function isWhiteSpace(charCode) {\n    return 9 === charCode || 32 === charCode || 0xB === charCode || 0xC === charCode;\n  }\n\n  function isLineTerminator(charCode) {\n    return 10 === charCode || 13 === charCode;\n  }\n\n  function isDecDigit(charCode) {\n    return charCode >= 48 && charCode <= 57;\n  }\n\n  function isHexDigit(charCode) {\n    return (charCode >= 48 && charCode <= 57) || (charCode >= 97 && charCode <= 102) || (charCode >= 65 && charCode <= 70);\n  }\n\n  // From [Lua 5.2](http://www.lua.org/manual/5.2/manual.html#8.1) onwards\n  // identifiers cannot use 'locale-dependent' letters (i.e. dependent on the C locale).\n  // On the other hand, LuaJIT allows arbitrary octets  128 in identifiers.\n\n  function isIdentifierStart(charCode) {\n    if ((charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122) || 95 === charCode)\n      return true;\n    if (features.extendedIdentifiers && charCode >= 128)\n      return true;\n    return false;\n  }\n\n  function isIdentifierPart(charCode) {\n    if ((charCode >= 65 && charCode <= 90) || (charCode >= 97 && charCode <= 122) || 95 === charCode || (charCode >= 48 && charCode <= 57))\n      return true;\n    if (features.extendedIdentifiers && charCode >= 128)\n      return true;\n    return false;\n  }\n\n  // [3.1 Lexical Conventions](http://www.lua.org/manual/5.2/manual.html#3.1)\n  //\n  // `true`, `false` and `nil` will not be considered keywords, but literals.\n\n  function isKeyword(id) {\n    switch (id.length) {\n      case 2:\n        return 'do' === id || 'if' === id || 'in' === id || 'or' === id;\n      case 3:\n        return 'and' === id || 'end' === id || 'for' === id || 'not' === id;\n      case 4:\n        if ('else' === id || 'then' === id)\n          return true;\n        if (features.labels && !features.contextualGoto)\n          return ('goto' === id);\n        return false;\n      case 5:\n        return 'break' === id || 'local' === id || 'until' === id || 'while' === id;\n      case 6:\n        return 'elseif' === id || 'repeat' === id || 'return' === id;\n      case 8:\n        return 'function' === id;\n    }\n    return false;\n  }\n\n  function isUnary(token) {\n    if (Punctuator === token.type) return '#-~'.indexOf(token.value) >= 0;\n    if (Keyword === token.type) return 'not' === token.value;\n    return false;\n  }\n\n  // Check if the token syntactically closes a block.\n\n  function isBlockFollow(token) {\n    if (EOF === token.type) return true;\n    if (Keyword !== token.type) return false;\n    switch (token.value) {\n      case 'else': case 'elseif':\n      case 'end': case 'until':\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  // Scope\n  // -----\n\n  // Store each block scope as a an array of identifier names. Each scope is\n  // stored in an FILO-array.\n  var scopes\n    // The current scope index\n    , scopeDepth\n    // A list of all global identifier nodes.\n    , globals;\n\n  // Create a new scope inheriting all declarations from the previous scope.\n  function createScope() {\n    var scope = scopes[scopeDepth++].slice();\n    scopes.push(scope);\n    if (options.onCreateScope) options.onCreateScope();\n  }\n\n  // Exit and remove the current scope.\n  function destroyScope() {\n    var scope = scopes.pop();\n    --scopeDepth;\n    if (options.onDestroyScope) options.onDestroyScope();\n  }\n\n  // Add identifier name to the current scope if it doesnt already exist.\n  function scopeIdentifierName(name) {\n    if (options.onLocalDeclaration) options.onLocalDeclaration(name);\n    if (-1 !== indexOf(scopes[scopeDepth], name)) return;\n    scopes[scopeDepth].push(name);\n  }\n\n  // Add identifier to the current scope\n  function scopeIdentifier(node) {\n    scopeIdentifierName(node.name);\n    attachScope(node, true);\n  }\n\n  // Attach scope information to node. If the node is global, store it in the\n  // globals array so we can return the information to the user.\n  function attachScope(node, isLocal) {\n    if (!isLocal && -1 === indexOfObject(globals, 'name', node.name))\n      globals.push(node);\n\n    node.isLocal = isLocal;\n  }\n\n  // Is the identifier name available in this scope.\n  function scopeHasName(name) {\n    return (-1 !== indexOf(scopes[scopeDepth], name));\n  }\n\n  // Location tracking\n  // -----------------\n  //\n  // Locations are stored in FILO-array as a `Marker` object consisting of both\n  // `loc` and `range` data. Once a `Marker` is popped off the list an end\n  // location is added and the data is attached to a syntax node.\n\n  var locations = []\n    , trackLocations;\n\n  function createLocationMarker() {\n    return new Marker(token);\n  }\n\n  function Marker(token) {\n    if (options.locations) {\n      this.loc = {\n          start: {\n            line: token.line\n          , column: token.range[0] - token.lineStart\n        }\n        , end: {\n            line: 0\n          , column: 0\n        }\n      };\n    }\n    if (options.ranges) this.range = [token.range[0], 0];\n  }\n\n  // Complete the location data stored in the `Marker` by adding the location\n  // of the *previous token* as an end location.\n  Marker.prototype.complete = function() {\n    if (options.locations) {\n      this.loc.end.line = previousToken.lastLine || previousToken.line;\n      this.loc.end.column = previousToken.range[1] - (previousToken.lastLineStart || previousToken.lineStart);\n    }\n    if (options.ranges) {\n      this.range[1] = previousToken.range[1];\n    }\n  };\n\n  Marker.prototype.bless = function (node) {\n    if (this.loc) {\n      var loc = this.loc;\n      node.loc = {\n        start: {\n          line: loc.start.line,\n          column: loc.start.column\n        },\n        end: {\n          line: loc.end.line,\n          column: loc.end.column\n        }\n      };\n    }\n    if (this.range) {\n      node.range = [\n        this.range[0],\n        this.range[1]\n      ];\n    }\n  };\n\n  // Create a new `Marker` and add it to the FILO-array.\n  function markLocation() {\n    if (trackLocations) locations.push(createLocationMarker());\n  }\n\n  // Push an arbitrary `Marker` object onto the FILO-array.\n  function pushLocation(marker) {\n    if (trackLocations) locations.push(marker);\n  }\n\n  // Control flow tracking\n  // ---------------------\n  // A context object that validates loop breaks and `goto`-based control flow.\n\n  function FullFlowContext() {\n    this.scopes = [];\n    this.pendingGotos = [];\n  }\n\n  FullFlowContext.prototype.isInLoop = function () {\n    var i = this.scopes.length;\n    while (i --> 0) {\n      if (this.scopes[i].isLoop)\n        return true;\n    }\n    return false;\n  };\n\n  FullFlowContext.prototype.pushScope = function (isLoop) {\n    var scope = {\n      labels: {},\n      locals: [],\n      deferredGotos: [],\n      isLoop: !!isLoop\n    };\n    this.scopes.push(scope);\n  };\n\n  FullFlowContext.prototype.popScope = function () {\n    for (var i = 0; i < this.pendingGotos.length; ++i) {\n      var theGoto = this.pendingGotos[i];\n      if (theGoto.maxDepth >= this.scopes.length)\n        if (--theGoto.maxDepth <= 0)\n          raise(theGoto.token, errors.labelNotVisible, theGoto.target);\n    }\n\n    this.scopes.pop();\n  };\n\n  FullFlowContext.prototype.addGoto = function (target, token) {\n    var localCounts = [];\n\n    for (var i = 0; i < this.scopes.length; ++i) {\n      var scope = this.scopes[i];\n      localCounts.push(scope.locals.length);\n      if (Object.prototype.hasOwnProperty.call(scope.labels, target))\n        return;\n    }\n\n    this.pendingGotos.push({\n      maxDepth: this.scopes.length,\n      target: target,\n      token: token,\n      localCounts: localCounts\n    });\n  };\n\n  FullFlowContext.prototype.addLabel = function (name, token) {\n    var scope = this.currentScope();\n\n    if (Object.prototype.hasOwnProperty.call(scope.labels, name)) {\n      raise(token, errors.labelAlreadyDefined, name, scope.labels[name].line);\n    } else {\n      var newGotos = [];\n\n      for (var i = 0; i < this.pendingGotos.length; ++i) {\n        var theGoto = this.pendingGotos[i];\n\n        if (theGoto.maxDepth >= this.scopes.length && theGoto.target === name) {\n          if (theGoto.localCounts[this.scopes.length - 1] < scope.locals.length) {\n            scope.deferredGotos.push(theGoto);\n          }\n          continue;\n        }\n\n        newGotos.push(theGoto);\n      }\n\n      this.pendingGotos = newGotos;\n    }\n\n    scope.labels[name] = {\n      localCount: scope.locals.length,\n      line: token.line\n    };\n  };\n\n  FullFlowContext.prototype.addLocal = function (name, token) {\n    this.currentScope().locals.push({\n      name: name,\n      token: token\n    });\n  };\n\n  FullFlowContext.prototype.currentScope = function () {\n    return this.scopes[this.scopes.length - 1];\n  };\n\n  FullFlowContext.prototype.raiseDeferredErrors = function () {\n    var scope = this.currentScope();\n    var bads = scope.deferredGotos;\n    for (var i = 0; i < bads.length; ++i) {\n      var theGoto = bads[i];\n      raise(theGoto.token, errors.gotoJumpInLocalScope, theGoto.target, scope.locals[theGoto.localCounts[this.scopes.length - 1]].name);\n    }\n    // Would be dead code currently, but may be useful later\n    // if (bads.length)\n    //   scope.deferredGotos = [];\n  };\n\n  // Simplified context that only checks the validity of loop breaks.\n\n  function LoopFlowContext() {\n    this.level = 0;\n    this.loopLevels = [];\n  }\n\n  LoopFlowContext.prototype.isInLoop = function () {\n    return !!this.loopLevels.length;\n  };\n\n  LoopFlowContext.prototype.pushScope = function (isLoop) {\n    ++this.level;\n    if (isLoop)\n      this.loopLevels.push(this.level);\n  };\n\n  LoopFlowContext.prototype.popScope = function () {\n    var levels = this.loopLevels;\n    var levlen = levels.length;\n    if (levlen) {\n      if (levels[levlen - 1] === this.level)\n        levels.pop();\n    }\n    --this.level;\n  };\n\n  LoopFlowContext.prototype.addGoto =\n  LoopFlowContext.prototype.addLabel =\n  /* istanbul ignore next */\n  function () { throw new Error('This should never happen'); };\n\n  LoopFlowContext.prototype.addLocal =\n  LoopFlowContext.prototype.raiseDeferredErrors =\n  function () {};\n\n  function makeFlowContext() {\n    return features.labels ? new FullFlowContext() : new LoopFlowContext();\n  }\n\n  // Parse functions\n  // ---------------\n\n  // Chunk is the main program object. Syntactically it's the same as a block.\n  //\n  //     chunk ::= block\n\n  function parseChunk() {\n    next();\n    markLocation();\n    if (options.scope) createScope();\n    var flowContext = makeFlowContext();\n    flowContext.allowVararg = true;\n    flowContext.pushScope();\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    if (EOF !== token.type) unexpected(token);\n    // If the body is empty no previousToken exists when finishNode runs.\n    if (trackLocations && !body.length) previousToken = token;\n    return finishNode(ast.chunk(body));\n  }\n\n  // A block contains a list of statements with an optional return statement\n  // as its last statement.\n  //\n  //     block ::= {stat} [retstat]\n\n  function parseBlock(flowContext) {\n    var block = []\n      , statement;\n\n    while (!isBlockFollow(token)) {\n      // Return has to be the last statement in a block.\n      // Likewise 'break' in Lua older than 5.2\n      if ('return' === token.value || (!features.relaxedBreak && 'break' === token.value)) {\n        block.push(parseStatement(flowContext));\n        break;\n      }\n      statement = parseStatement(flowContext);\n      consume(';');\n      // Statements are only added if they are returned, this allows us to\n      // ignore some statements, such as EmptyStatement.\n      if (statement) block.push(statement);\n    }\n\n    // Doesn't really need an ast node\n    return block;\n  }\n\n  // There are two types of statements, simple and compound.\n  //\n  //     statement ::= break | goto | do | while | repeat | return\n  //          | if | for | function | local | label | assignment\n  //          | functioncall | ';'\n\n  function parseStatement(flowContext) {\n    markLocation();\n\n    if (Punctuator === token.type) {\n      if (consume('::')) return parseLabelStatement(flowContext);\n    }\n\n    // When a `;` is encounted, simply eat it without storing it.\n    if (features.emptyStatement) {\n      if (consume(';')) {\n        if (trackLocations) locations.pop();\n        return;\n      }\n    }\n\n    flowContext.raiseDeferredErrors();\n\n    if (Keyword === token.type) {\n      switch (token.value) {\n        case 'local':    next(); return parseLocalStatement(flowContext);\n        case 'if':       next(); return parseIfStatement(flowContext);\n        case 'return':   next(); return parseReturnStatement(flowContext);\n        case 'function': next();\n          var name = parseFunctionName();\n          return parseFunctionDeclaration(name);\n        case 'while':    next(); return parseWhileStatement(flowContext);\n        case 'for':      next(); return parseForStatement(flowContext);\n        case 'repeat':   next(); return parseRepeatStatement(flowContext);\n        case 'break':    next();\n          if (!flowContext.isInLoop())\n            raise(token, errors.noLoopToBreak, token.value);\n          return parseBreakStatement();\n        case 'do':       next(); return parseDoStatement(flowContext);\n        case 'goto':     next(); return parseGotoStatement(flowContext);\n      }\n    }\n\n    if (features.contextualGoto &&\n        token.type === Identifier && token.value === 'goto' &&\n        lookahead.type === Identifier && lookahead.value !== 'goto') {\n      next(); return parseGotoStatement(flowContext);\n    }\n\n    // Assignments memorizes the location and pushes it manually for wrapper nodes.\n    if (trackLocations) locations.pop();\n\n    return parseAssignmentOrCallStatement(flowContext);\n  }\n\n  // ## Statements\n\n  //     label ::= '::' Name '::'\n\n  function parseLabelStatement(flowContext) {\n    var nameToken = token\n      , label = parseIdentifier();\n\n    if (options.scope) {\n      scopeIdentifierName('::' + nameToken.value + '::');\n      attachScope(label, true);\n    }\n\n    expect('::');\n\n    flowContext.addLabel(nameToken.value, nameToken);\n    return finishNode(ast.labelStatement(label));\n  }\n\n  //     break ::= 'break'\n\n  function parseBreakStatement() {\n    return finishNode(ast.breakStatement());\n  }\n\n  //     goto ::= 'goto' Name\n\n  function parseGotoStatement(flowContext) {\n    var name = token.value\n      , gotoToken = previousToken\n      , label = parseIdentifier();\n\n    flowContext.addGoto(name, gotoToken);\n    return finishNode(ast.gotoStatement(label));\n  }\n\n  //     do ::= 'do' block 'end'\n\n  function parseDoStatement(flowContext) {\n    if (options.scope) createScope();\n    flowContext.pushScope();\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    expect('end');\n    return finishNode(ast.doStatement(body));\n  }\n\n  //     while ::= 'while' exp 'do' block 'end'\n\n  function parseWhileStatement(flowContext) {\n    var condition = parseExpectedExpression(flowContext);\n    expect('do');\n    if (options.scope) createScope();\n    flowContext.pushScope(true);\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    expect('end');\n    return finishNode(ast.whileStatement(condition, body));\n  }\n\n  //     repeat ::= 'repeat' block 'until' exp\n\n  function parseRepeatStatement(flowContext) {\n    if (options.scope) createScope();\n    flowContext.pushScope(true);\n    var body = parseBlock(flowContext);\n    expect('until');\n    flowContext.raiseDeferredErrors();\n    var condition = parseExpectedExpression(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    return finishNode(ast.repeatStatement(condition, body));\n  }\n\n  //     retstat ::= 'return' [exp {',' exp}] [';']\n\n  function parseReturnStatement(flowContext) {\n    var expressions = [];\n\n    if ('end' !== token.value) {\n      var expression = parseExpression(flowContext);\n      if (null != expression) expressions.push(expression);\n      while (consume(',')) {\n        expression = parseExpectedExpression(flowContext);\n        expressions.push(expression);\n      }\n      consume(';'); // grammar tells us ; is optional here.\n    }\n    return finishNode(ast.returnStatement(expressions));\n  }\n\n  //     if ::= 'if' exp 'then' block {elif} ['else' block] 'end'\n  //     elif ::= 'elseif' exp 'then' block\n\n  function parseIfStatement(flowContext) {\n    var clauses = []\n      , condition\n      , body\n      , marker;\n\n    // IfClauses begin at the same location as the parent IfStatement.\n    // It ends at the start of `end`, `else`, or `elseif`.\n    if (trackLocations) {\n      marker = locations[locations.length - 1];\n      locations.push(marker);\n    }\n    condition = parseExpectedExpression(flowContext);\n    expect('then');\n    if (options.scope) createScope();\n    flowContext.pushScope();\n    body = parseBlock(flowContext);\n    flowContext.popScope();\n    if (options.scope) destroyScope();\n    clauses.push(finishNode(ast.ifClause(condition, body)));\n\n    if (trackLocations) marker = createLocationMarker();\n    while (consume('elseif')) {\n      pushLocation(marker);\n      condition = parseExpectedExpression(flowContext);\n      expect('then');\n      if (options.scope) createScope();\n      flowContext.pushScope();\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      clauses.push(finishNode(ast.elseifClause(condition, body)));\n      if (trackLocations) marker = createLocationMarker();\n    }\n\n    if (consume('else')) {\n      // Include the `else` in the location of ElseClause.\n      if (trackLocations) {\n        marker = new Marker(previousToken);\n        locations.push(marker);\n      }\n      if (options.scope) createScope();\n      flowContext.pushScope();\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      if (options.scope) destroyScope();\n      clauses.push(finishNode(ast.elseClause(body)));\n    }\n\n    expect('end');\n    return finishNode(ast.ifStatement(clauses));\n  }\n\n  // There are two types of for statements, generic and numeric.\n  //\n  //     for ::= Name '=' exp ',' exp [',' exp] 'do' block 'end'\n  //     for ::= namelist 'in' explist 'do' block 'end'\n  //     namelist ::= Name {',' Name}\n  //     explist ::= exp {',' exp}\n\n  function parseForStatement(flowContext) {\n    var variable = parseIdentifier()\n      , body;\n\n    // The start-identifier is local.\n\n    if (options.scope) {\n      createScope();\n      scopeIdentifier(variable);\n    }\n\n    // If the first expression is followed by a `=` punctuator, this is a\n    // Numeric For Statement.\n    if (consume('=')) {\n      // Start expression\n      var start = parseExpectedExpression(flowContext);\n      expect(',');\n      // End expression\n      var end = parseExpectedExpression(flowContext);\n      // Optional step expression\n      var step = consume(',') ? parseExpectedExpression(flowContext) : null;\n\n      expect('do');\n      flowContext.pushScope(true);\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      expect('end');\n      if (options.scope) destroyScope();\n\n      return finishNode(ast.forNumericStatement(variable, start, end, step, body));\n    }\n    // If not, it's a Generic For Statement\n    else {\n      // The namelist can contain one or more identifiers.\n      var variables = [variable];\n      while (consume(',')) {\n        variable = parseIdentifier();\n        // Each variable in the namelist is locally scoped.\n        if (options.scope) scopeIdentifier(variable);\n        variables.push(variable);\n      }\n      expect('in');\n      var iterators = [];\n\n      // One or more expressions in the explist.\n      do {\n        var expression = parseExpectedExpression(flowContext);\n        iterators.push(expression);\n      } while (consume(','));\n\n      expect('do');\n      flowContext.pushScope(true);\n      body = parseBlock(flowContext);\n      flowContext.popScope();\n      expect('end');\n      if (options.scope) destroyScope();\n\n      return finishNode(ast.forGenericStatement(variables, iterators, body));\n    }\n  }\n\n  // Local statements can either be variable assignments or function\n  // definitions. If a function definition is found, it will be delegated to\n  // `parseFunctionDeclaration()` with the isLocal flag.\n  //\n  // This AST structure might change into a local assignment with a function\n  // child.\n  //\n  //     local ::= 'local' 'function' Name funcdecl\n  //        | 'local' Name {',' Name} ['=' exp {',' exp}]\n\n  function parseLocalStatement(flowContext) {\n    var name\n      , declToken = previousToken;\n\n    if (Identifier === token.type) {\n      var variables = []\n        , init = [];\n\n      do {\n        name = parseIdentifier();\n\n        variables.push(name);\n        flowContext.addLocal(name.name, declToken);\n      } while (consume(','));\n\n      if (consume('=')) {\n        do {\n          var expression = parseExpectedExpression(flowContext);\n          init.push(expression);\n        } while (consume(','));\n      }\n\n      // Declarations doesn't exist before the statement has been evaluated.\n      // Therefore assignments can't use their declarator. And the identifiers\n      // shouldn't be added to the scope until the statement is complete.\n      if (options.scope) {\n        for (var i = 0, l = variables.length; i < l; ++i) {\n          scopeIdentifier(variables[i]);\n        }\n      }\n\n      return finishNode(ast.localStatement(variables, init));\n    }\n    if (consume('function')) {\n      name = parseIdentifier();\n      flowContext.addLocal(name.name, declToken);\n\n      if (options.scope) {\n        scopeIdentifier(name);\n        createScope();\n      }\n\n      // MemberExpressions are not allowed in local function statements.\n      return parseFunctionDeclaration(name, true);\n    } else {\n      raiseUnexpectedToken('<name>', token);\n    }\n  }\n\n  //     assignment ::= varlist '=' explist\n  //     var ::= Name | prefixexp '[' exp ']' | prefixexp '.' Name\n  //     varlist ::= var {',' var}\n  //     explist ::= exp {',' exp}\n  //\n  //     call ::= callexp\n  //     callexp ::= prefixexp args | prefixexp ':' Name args\n\n  function parseAssignmentOrCallStatement(flowContext) {\n    // Keep a reference to the previous token for better error messages in case\n    // of invalid statement\n    var previous = token\n      , marker, startMarker;\n    var lvalue, base, name;\n\n    var targets = [];\n\n    if (trackLocations) startMarker = createLocationMarker();\n\n    do {\n      if (trackLocations) marker = createLocationMarker();\n\n      if (Identifier === token.type) {\n        name = token.value;\n        base = parseIdentifier();\n        // Set the parent scope.\n        if (options.scope) attachScope(base, scopeHasName(name));\n        lvalue = true;\n      } else if ('(' === token.value) {\n        next();\n        base = parseExpectedExpression(flowContext);\n        expect(')');\n        lvalue = false;\n      } else {\n        return unexpected(token);\n      }\n\n      both: for (;;) {\n        var newBase;\n\n        switch (StringLiteral === token.type ? '\"' : token.value) {\n        case '.':\n        case '[':\n          lvalue = true;\n          break;\n        case ':':\n        case '(':\n        case '{':\n        case '\"':\n          lvalue = null;\n          break;\n        default:\n          break both;\n        }\n\n        base = parsePrefixExpressionPart(base, marker, flowContext);\n      }\n\n      targets.push(base);\n\n      if (',' !== token.value)\n        break;\n\n      if (!lvalue) {\n        return unexpected(token);\n      }\n\n      next();\n    } while (true);\n\n    if (targets.length === 1 && lvalue === null) {\n      pushLocation(marker);\n      return finishNode(ast.callStatement(targets[0]));\n    } else if (!lvalue) {\n      return unexpected(token);\n    }\n\n    expect('=');\n\n    var values = [];\n\n    do {\n      values.push(parseExpectedExpression(flowContext));\n    } while (consume(','));\n\n    pushLocation(startMarker);\n    return finishNode(ast.assignmentStatement(targets, values));\n  }\n\n  // ### Non-statements\n\n  //     Identifier ::= Name\n\n  function parseIdentifier() {\n    markLocation();\n    var identifier = token.value;\n    if (Identifier !== token.type) raiseUnexpectedToken('<name>', token);\n    next();\n    return finishNode(ast.identifier(identifier));\n  }\n\n  // Parse the functions parameters and body block. The name should already\n  // have been parsed and passed to this declaration function. By separating\n  // this we allow for anonymous functions in expressions.\n  //\n  // For local functions there's a boolean parameter which needs to be set\n  // when parsing the declaration.\n  //\n  //     funcdecl ::= '(' [parlist] ')' block 'end'\n  //     parlist ::= Name {',' Name} | [',' '...'] | '...'\n\n  function parseFunctionDeclaration(name, isLocal) {\n    var flowContext = makeFlowContext();\n    flowContext.pushScope();\n\n    var parameters = [];\n    expect('(');\n\n    // The declaration has arguments\n    if (!consume(')')) {\n      // Arguments are a comma separated list of identifiers, optionally ending\n      // with a vararg.\n      while (true) {\n        if (Identifier === token.type) {\n          var parameter = parseIdentifier();\n          // Function parameters are local.\n          if (options.scope) scopeIdentifier(parameter);\n\n          parameters.push(parameter);\n\n          if (consume(',')) continue;\n        }\n        // No arguments are allowed after a vararg.\n        else if (VarargLiteral === token.type) {\n          flowContext.allowVararg = true;\n          parameters.push(parsePrimaryExpression(flowContext));\n        } else {\n          raiseUnexpectedToken('<name> or \\'...\\'', token);\n        }\n        expect(')');\n        break;\n      }\n    }\n\n    var body = parseBlock(flowContext);\n    flowContext.popScope();\n    expect('end');\n    if (options.scope) destroyScope();\n\n    isLocal = isLocal || false;\n    return finishNode(ast.functionStatement(name, parameters, isLocal, body));\n  }\n\n  // Parse the function name as identifiers and member expressions.\n  //\n  //     Name {'.' Name} [':' Name]\n\n  function parseFunctionName() {\n    var base, name, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n    base = parseIdentifier();\n\n    if (options.scope) {\n      attachScope(base, scopeHasName(base.name));\n      createScope();\n    }\n\n    while (consume('.')) {\n      pushLocation(marker);\n      name = parseIdentifier();\n      base = finishNode(ast.memberExpression(base, '.', name));\n    }\n\n    if (consume(':')) {\n      pushLocation(marker);\n      name = parseIdentifier();\n      base = finishNode(ast.memberExpression(base, ':', name));\n      if (options.scope) scopeIdentifierName('self');\n    }\n\n    return base;\n  }\n\n  //     tableconstructor ::= '{' [fieldlist] '}'\n  //     fieldlist ::= field {fieldsep field} fieldsep\n  //     field ::= '[' exp ']' '=' exp | Name = 'exp' | exp\n  //\n  //     fieldsep ::= ',' | ';'\n\n  function parseTableConstructor(flowContext) {\n    var fields = []\n      , key, value;\n\n    while (true) {\n      markLocation();\n      if (Punctuator === token.type && consume('[')) {\n        key = parseExpectedExpression(flowContext);\n        expect(']');\n        expect('=');\n        value = parseExpectedExpression(flowContext);\n        fields.push(finishNode(ast.tableKey(key, value)));\n      } else if (Identifier === token.type) {\n        if ('=' === lookahead.value) {\n          key = parseIdentifier();\n          next();\n          value = parseExpectedExpression(flowContext);\n          fields.push(finishNode(ast.tableKeyString(key, value)));\n        } else {\n          value = parseExpectedExpression(flowContext);\n          fields.push(finishNode(ast.tableValue(value)));\n        }\n      } else {\n        if (null == (value = parseExpression(flowContext))) {\n          locations.pop();\n          break;\n        }\n        fields.push(finishNode(ast.tableValue(value)));\n      }\n      if (',;'.indexOf(token.value) >= 0) {\n        next();\n        continue;\n      }\n      break;\n    }\n    expect('}');\n    return finishNode(ast.tableConstructorExpression(fields));\n  }\n\n  // Expression parser\n  // -----------------\n  //\n  // Expressions are evaluated and always return a value. If nothing is\n  // matched null will be returned.\n  //\n  //     exp ::= (unop exp | primary | prefixexp ) { binop exp }\n  //\n  //     primary ::= nil | false | true | Number | String | '...'\n  //          | functiondef | tableconstructor\n  //\n  //     prefixexp ::= (Name | '(' exp ')' ) { '[' exp ']'\n  //          | '.' Name | ':' Name args | args }\n  //\n\n  function parseExpression(flowContext) {\n    var expression = parseSubExpression(0, flowContext);\n    return expression;\n  }\n\n  // Parse an expression expecting it to be valid.\n\n  function parseExpectedExpression(flowContext) {\n    var expression = parseExpression(flowContext);\n    if (null == expression) raiseUnexpectedToken('<expression>', token);\n    else return expression;\n  }\n\n\n  // Return the precedence priority of the operator.\n  //\n  // As unary `-` can't be distinguished from binary `-`, unary precedence\n  // isn't described in this table but in `parseSubExpression()` itself.\n  //\n  // As this function gets hit on every expression it's been optimized due to\n  // the expensive CompareICStub which took ~8% of the parse time.\n\n  function binaryPrecedence(operator) {\n    var charCode = operator.charCodeAt(0)\n      , length = operator.length;\n\n    if (1 === length) {\n      switch (charCode) {\n        case 94: return 12; // ^\n        case 42: case 47: case 37: return 10; // * / %\n        case 43: case 45: return 9; // + -\n        case 38: return 6; // &\n        case 126: return 5; // ~\n        case 124: return 4; // |\n        case 60: case 62: return 3; // < >\n      }\n    } else if (2 === length) {\n      switch (charCode) {\n        case 47: return 10; // //\n        case 46: return 8; // ..\n        case 60: case 62:\n            if('<<' === operator || '>>' === operator) return 7; // << >>\n            return 3; // <= >=\n        case 61: case 126: return 3; // == ~=\n        case 111: return 1; // or\n      }\n    } else if (97 === charCode && 'and' === operator) return 2;\n    return 0;\n  }\n\n  // Implement an operator-precedence parser to handle binary operator\n  // precedence.\n  //\n  // We use this algorithm because it's compact, it's fast and Lua core uses\n  // the same so we can be sure our expressions are parsed in the same manner\n  // without excessive amounts of tests.\n  //\n  //     exp ::= (unop exp | primary | prefixexp ) { binop exp }\n\n  function parseSubExpression(minPrecedence, flowContext) {\n    var operator = token.value\n    // The left-hand side in binary operations.\n      , expression, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    // UnaryExpression\n    if (isUnary(token)) {\n      markLocation();\n      next();\n      var argument = parseSubExpression(10, flowContext);\n      if (argument == null) raiseUnexpectedToken('<expression>', token);\n      expression = finishNode(ast.unaryExpression(operator, argument));\n    }\n    if (null == expression) {\n      // PrimaryExpression\n      expression = parsePrimaryExpression(flowContext);\n\n      // PrefixExpression\n      if (null == expression) {\n        expression = parsePrefixExpression(flowContext);\n      }\n    }\n    // This is not a valid left hand expression.\n    if (null == expression) return null;\n\n    var precedence;\n    while (true) {\n      operator = token.value;\n\n      precedence = (Punctuator === token.type || Keyword === token.type) ?\n        binaryPrecedence(operator) : 0;\n\n      if (precedence === 0 || precedence <= minPrecedence) break;\n      // Right-hand precedence operators\n      if ('^' === operator || '..' === operator) --precedence;\n      next();\n      var right = parseSubExpression(precedence, flowContext);\n      if (null == right) raiseUnexpectedToken('<expression>', token);\n      // Push in the marker created before the loop to wrap its entirety.\n      if (trackLocations) locations.push(marker);\n      expression = finishNode(ast.binaryExpression(operator, expression, right));\n\n    }\n    return expression;\n  }\n\n  //     prefixexp ::= prefix {suffix}\n  //     prefix ::= Name | '(' exp ')'\n  //     suffix ::= '[' exp ']' | '.' Name | ':' Name args | args\n  //\n  //     args ::= '(' [explist] ')' | tableconstructor | String\n\n  function parsePrefixExpressionPart(base, marker, flowContext) {\n    var expression, identifier;\n\n    if (Punctuator === token.type) {\n      switch (token.value) {\n        case '[':\n          pushLocation(marker);\n          next();\n          expression = parseExpectedExpression(flowContext);\n          expect(']');\n          return finishNode(ast.indexExpression(base, expression));\n        case '.':\n          pushLocation(marker);\n          next();\n          identifier = parseIdentifier();\n          return finishNode(ast.memberExpression(base, '.', identifier));\n        case ':':\n          pushLocation(marker);\n          next();\n          identifier = parseIdentifier();\n          base = finishNode(ast.memberExpression(base, ':', identifier));\n          // Once a : is found, this has to be a CallExpression, otherwise\n          // throw an error.\n          pushLocation(marker);\n          return parseCallExpression(base, flowContext);\n        case '(': case '{': // args\n          pushLocation(marker);\n          return parseCallExpression(base, flowContext);\n      }\n    } else if (StringLiteral === token.type) {\n      pushLocation(marker);\n      return parseCallExpression(base, flowContext);\n    }\n\n    return null;\n  }\n\n  function parsePrefixExpression(flowContext) {\n    var base, name, marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    // The prefix\n    if (Identifier === token.type) {\n      name = token.value;\n      base = parseIdentifier();\n      // Set the parent scope.\n      if (options.scope) attachScope(base, scopeHasName(name));\n    } else if (consume('(')) {\n      base = parseExpectedExpression(flowContext);\n      expect(')');\n    } else {\n      return null;\n    }\n\n    // The suffix\n    for (;;) {\n      var newBase = parsePrefixExpressionPart(base, marker, flowContext);\n      if (newBase === null)\n        break;\n      base = newBase;\n    }\n\n    return base;\n  }\n\n  //     args ::= '(' [explist] ')' | tableconstructor | String\n\n  function parseCallExpression(base, flowContext) {\n    if (Punctuator === token.type) {\n      switch (token.value) {\n        case '(':\n          if (!features.emptyStatement) {\n            if (token.line !== previousToken.line)\n              raise(null, errors.ambiguousSyntax, token.value);\n          }\n          next();\n\n          // List of expressions\n          var expressions = [];\n          var expression = parseExpression(flowContext);\n          if (null != expression) expressions.push(expression);\n          while (consume(',')) {\n            expression = parseExpectedExpression(flowContext);\n            expressions.push(expression);\n          }\n\n          expect(')');\n          return finishNode(ast.callExpression(base, expressions));\n\n        case '{':\n          markLocation();\n          next();\n          var table = parseTableConstructor(flowContext);\n          return finishNode(ast.tableCallExpression(base, table));\n      }\n    } else if (StringLiteral === token.type) {\n      return finishNode(ast.stringCallExpression(base, parsePrimaryExpression(flowContext)));\n    }\n\n    raiseUnexpectedToken('function arguments', token);\n  }\n\n  //     primary ::= String | Numeric | nil | true | false\n  //          | functiondef | tableconstructor | '...'\n\n  function parsePrimaryExpression(flowContext) {\n    var literals = StringLiteral | NumericLiteral | BooleanLiteral | NilLiteral | VarargLiteral\n      , value = token.value\n      , type = token.type\n      , marker;\n\n    if (trackLocations) marker = createLocationMarker();\n\n    if (type === VarargLiteral && !flowContext.allowVararg) {\n      raise(token, errors.cannotUseVararg, token.value);\n    }\n\n    if (type & literals) {\n      pushLocation(marker);\n      var raw = input.slice(token.range[0], token.range[1]);\n      next();\n      return finishNode(ast.literal(type, value, raw));\n    } else if (Keyword === type && 'function' === value) {\n      pushLocation(marker);\n      next();\n      if (options.scope) createScope();\n      return parseFunctionDeclaration(null);\n    } else if (consume('{')) {\n      pushLocation(marker);\n      return parseTableConstructor(flowContext);\n    }\n  }\n\n  // Parser\n  // ------\n\n  // Export the main parser.\n  //\n  //   - `wait` Hold parsing until end() is called. Defaults to false\n  //   - `comments` Store comments. Defaults to true.\n  //   - `scope` Track identifier scope. Defaults to false.\n  //   - `locations` Store location information. Defaults to false.\n  //   - `ranges` Store the start and end character locations. Defaults to\n  //     false.\n  //   - `onCreateNode` Callback which will be invoked when a syntax node is\n  //     created.\n  //   - `onCreateScope` Callback which will be invoked when a new scope is\n  //     created.\n  //   - `onDestroyScope` Callback which will be invoked when the current scope\n  //     is destroyed.\n  //\n  // Example:\n  //\n  //     var parser = require('luaparser');\n  //     parser.parse('i = 0');\n\n  exports.parse = parse;\n\n  var versionFeatures = {\n    '5.1': {\n    },\n    '5.2': {\n      labels: true,\n      emptyStatement: true,\n      hexEscapes: true,\n      skipWhitespaceEscape: true,\n      strictEscapes: true,\n      relaxedBreak: true\n    },\n    '5.3': {\n      labels: true,\n      emptyStatement: true,\n      hexEscapes: true,\n      skipWhitespaceEscape: true,\n      strictEscapes: true,\n      unicodeEscapes: true,\n      bitwiseOperators: true,\n      integerDivision: true,\n      relaxedBreak: true\n    },\n    'LuaJIT': {\n      // XXX: LuaJIT language features may depend on compilation options; may need to\n      // rethink how to handle this. Specifically, there is a LUAJIT_ENABLE_LUA52COMPAT\n      // that removes contextual goto. Maybe add 'LuaJIT-5.2compat' as well?\n      labels: true,\n      contextualGoto: true,\n      hexEscapes: true,\n      skipWhitespaceEscape: true,\n      strictEscapes: true,\n      unicodeEscapes: true,\n      imaginaryNumbers: true,\n      integerSuffixes: true\n    }\n  };\n\n  function parse(_input, _options) {\n    if ('undefined' === typeof _options && 'object' === typeof _input) {\n      _options = _input;\n      _input = undefined;\n    }\n    if (!_options) _options = {};\n\n    input = _input || '';\n    options = assign({}, defaultOptions, _options);\n\n    // Rewind the lexer\n    index = 0;\n    line = 1;\n    lineStart = 0;\n    length = input.length;\n    // When tracking identifier scope, initialize with an empty scope.\n    scopes = [[]];\n    scopeDepth = 0;\n    globals = [];\n    locations = [];\n\n    if (!Object.prototype.hasOwnProperty.call(versionFeatures, options.luaVersion)) {\n      throw new Error(sprintf(\"Lua version '%1' not supported\", options.luaVersion));\n    }\n\n    features = assign({}, versionFeatures[options.luaVersion]);\n    if (options.extendedIdentifiers !== void 0)\n      features.extendedIdentifiers = !!options.extendedIdentifiers;\n\n    if (!Object.prototype.hasOwnProperty.call(encodingModes, options.encodingMode)) {\n      throw new Error(sprintf(\"Encoding mode '%1' not supported\", options.encodingMode));\n    }\n\n    encodingMode = encodingModes[options.encodingMode];\n\n    if (options.comments) comments = [];\n    if (!options.wait) return end();\n    return exports;\n  }\n\n  // Write to the source code buffer without beginning the parse.\n  exports.write = write;\n\n  function write(_input) {\n    input += String(_input);\n    length = input.length;\n    return exports;\n  }\n\n  // Send an EOF and begin parsing.\n  exports.end = end;\n\n  function end(_input) {\n    if ('undefined' !== typeof _input) write(_input);\n\n    // Ignore shebangs.\n    if (input && input.substr(0, 2) === '#!') input = input.replace(/^.*/, function (line) {\n      return line.replace(/./g, ' ');\n    });\n\n    length = input.length;\n    trackLocations = options.locations || options.ranges;\n    // Initialize with a lookahead token.\n    lookahead = lex();\n\n    var chunk = parseChunk();\n    if (options.comments) chunk.comments = comments;\n    if (options.scope) chunk.globals = globals;\n\n    /* istanbul ignore if */\n    if (locations.length > 0)\n      throw new Error('Location tracking failed. This is most likely a bug in luaparse');\n\n    return chunk;\n  }\n\n}));\n/* vim: set sw=2 ts=2 et tw=79 : */\n","import * as lsp from \"vscode-languageserver-protocol\";\r\nimport {AceLinters} from \"../types\";\r\nimport {mergeObjects} from \"../utils\";\r\nimport {TextDocument} from \"vscode-languageserver-textdocument\";\r\n\r\nexport abstract class BaseService<OptionsType extends AceLinters.ServiceOptions = AceLinters.ServiceOptions> implements AceLinters.LanguageService {\r\n    abstract $service;\r\n    mode: string;\r\n    documents: { [sessionID: string]: TextDocument } = {};\r\n    options: { [sessionID: string]: OptionsType } = {};\r\n    globalOptions: OptionsType = {} as OptionsType;\r\n\r\n    protected constructor(mode: string) {\r\n        this.mode = mode;\r\n    }\r\n\r\n    addDocument(document: lsp.TextDocumentItem) {\r\n        this.documents[document.uri] = TextDocument.create(document.uri, document.languageId, document.version,\r\n            (document as lsp.TextDocumentItem).text)\r\n        //TODO:\r\n        /*if (options)\r\n            this.setSessionOptions(sessionID, options);*/\r\n    }\r\n\r\n    getDocument(uri: string): TextDocument {\r\n        return this.documents[uri];\r\n    }\r\n\r\n    removeDocument(document: lsp.TextDocumentIdentifier) {\r\n        delete this.documents[document.uri];\r\n        if (this.options[document.uri]) {\r\n            delete this.options[document.uri];\r\n        }\r\n    }\r\n\r\n    getDocumentValue(uri: string): string {\r\n        return this.getDocument(uri).getText();\r\n    }\r\n\r\n    setValue(identifier: lsp.VersionedTextDocumentIdentifier, value: string) {\r\n        let document = this.getDocument(identifier.uri);\r\n        if (document) {\r\n            document = TextDocument.create(document.uri, document.languageId, document.version, value);\r\n            this.documents[document.uri] = document;\r\n        }\r\n    }\r\n\r\n    setGlobalOptions(options: OptionsType) {\r\n        this.globalOptions = options ?? {} as OptionsType;\r\n    }\r\n\r\n    setOptions(sessionID: string, options: OptionsType, merge = false) {\r\n        this.options[sessionID] = merge ? mergeObjects(options, this.options[sessionID]) : options;\r\n    }\r\n\r\n    getOption<T extends keyof OptionsType>(sessionID: string, optionName: T): OptionsType[T] {\r\n        if (this.options[sessionID] && this.options[sessionID][optionName]) {\r\n            return this.options[sessionID][optionName];\r\n        } else {\r\n            return this.globalOptions[optionName];\r\n        }\r\n    }\r\n\r\n    applyDeltas(identifier: lsp.VersionedTextDocumentIdentifier, deltas: lsp.TextDocumentContentChangeEvent[]) {\r\n        let document = this.getDocument(identifier.uri);\r\n        if (document)\r\n            TextDocument.update(document, deltas, identifier.version);\r\n    }\r\n\r\n    async doComplete(document, position: lsp.Position): Promise<lsp.CompletionItem[] | lsp.CompletionList | null> {\r\n        return null;\r\n    }\r\n\r\n    async doHover(document, position: lsp.Position): Promise<lsp.Hover | null> {\r\n        return null;\r\n    }\r\n\r\n    async doResolve(item: lsp.CompletionItem): Promise<lsp.CompletionItem | null> {\r\n        return null;\r\n    }\r\n\r\n    async doValidation(document): Promise<lsp.Diagnostic[]> {\r\n        return [];\r\n    }\r\n\r\n    format(document, range: lsp.Range, options: lsp.FormattingOptions): lsp.TextEdit[] {\r\n        return [];\r\n    }\r\n\r\n}\r\n","import {BaseService} from \"../base-service\";\r\nimport * as lua from \"luaparse\";\r\nimport {AceLinters} from \"../../types\";\r\nimport * as lsp from \"vscode-languageserver-protocol\";\r\n\r\nexport class LuaService extends BaseService implements AceLinters.LanguageService {\r\n    $service;\r\n\r\n    constructor(mode: string) {\r\n        super(mode);\r\n        this.$service = lua;\r\n    }\r\n\r\n    async doValidation(document: lsp.TextDocumentIdentifier): Promise<lsp.Diagnostic[]> {\r\n        let value = this.getDocumentValue(document.uri);\r\n        if (!value)\r\n            return [];\r\n\r\n        let errors: lsp.Diagnostic[] = [];\r\n        try {\r\n            this.$service.parse(value);\r\n        } catch (e) {\r\n            if (e instanceof this.$service.SyntaxError) {\r\n                errors.push({\r\n                    range: {\r\n                        start: {\r\n                            line: e.line - 1,\r\n                            character: e.column\r\n                        },\r\n                        end: {\r\n                            line: e.line - 1,\r\n                            character: e.column\r\n                        }\r\n                    },\r\n                    message: e.message,\r\n                    severity: 1\r\n                });\r\n            }\r\n        }\r\n        return errors;\r\n    }\r\n\r\n}\r\n","export function mergeObjects(obj1, obj2) {\r\n    if (!obj1) return obj2;\r\n    if (!obj2) return obj1;\r\n    const mergedObjects = {};\r\n    for (const key of [...Object.keys(obj1), ...Object.keys(obj2)]) {\r\n        if (obj1[key] && obj2[key]) {\r\n            if (Array.isArray(obj1[key])) {\r\n                mergedObjects[key] = obj1[key].concat(obj2[key]);\r\n            } else {\r\n                mergedObjects[key] = mergeObjects(obj1[key], obj2[key]);\r\n            }\r\n        } else {\r\n            mergedObjects[key] = obj1[key] ?? obj2[key];\r\n        }\r\n    }\r\n    return mergedObjects;\r\n}\r\n","/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar FullTextDocument = /** @class */ (function () {\n    function FullTextDocument(uri, languageId, version, content) {\n        this._uri = uri;\n        this._languageId = languageId;\n        this._version = version;\n        this._content = content;\n        this._lineOffsets = undefined;\n    }\n    Object.defineProperty(FullTextDocument.prototype, \"uri\", {\n        get: function () {\n            return this._uri;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\n        get: function () {\n            return this._languageId;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(FullTextDocument.prototype, \"version\", {\n        get: function () {\n            return this._version;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    FullTextDocument.prototype.getText = function (range) {\n        if (range) {\n            var start = this.offsetAt(range.start);\n            var end = this.offsetAt(range.end);\n            return this._content.substring(start, end);\n        }\n        return this._content;\n    };\n    FullTextDocument.prototype.update = function (changes, version) {\n        for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {\n            var change = changes_1[_i];\n            if (FullTextDocument.isIncremental(change)) {\n                // makes sure start is before end\n                var range = getWellformedRange(change.range);\n                // update content\n                var startOffset = this.offsetAt(range.start);\n                var endOffset = this.offsetAt(range.end);\n                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);\n                // update the offsets\n                var startLine = Math.max(range.start.line, 0);\n                var endLine = Math.max(range.end.line, 0);\n                var lineOffsets = this._lineOffsets;\n                var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);\n                if (endLine - startLine === addedLineOffsets.length) {\n                    for (var i = 0, len = addedLineOffsets.length; i < len; i++) {\n                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];\n                    }\n                }\n                else {\n                    if (addedLineOffsets.length < 10000) {\n                        lineOffsets.splice.apply(lineOffsets, __spreadArray([startLine + 1, endLine - startLine], addedLineOffsets, false));\n                    }\n                    else { // avoid too many arguments for splice\n                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\n                    }\n                }\n                var diff = change.text.length - (endOffset - startOffset);\n                if (diff !== 0) {\n                    for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {\n                        lineOffsets[i] = lineOffsets[i] + diff;\n                    }\n                }\n            }\n            else if (FullTextDocument.isFull(change)) {\n                this._content = change.text;\n                this._lineOffsets = undefined;\n            }\n            else {\n                throw new Error('Unknown change event received');\n            }\n        }\n        this._version = version;\n    };\n    FullTextDocument.prototype.getLineOffsets = function () {\n        if (this._lineOffsets === undefined) {\n            this._lineOffsets = computeLineOffsets(this._content, true);\n        }\n        return this._lineOffsets;\n    };\n    FullTextDocument.prototype.positionAt = function (offset) {\n        offset = Math.max(Math.min(offset, this._content.length), 0);\n        var lineOffsets = this.getLineOffsets();\n        var low = 0, high = lineOffsets.length;\n        if (high === 0) {\n            return { line: 0, character: offset };\n        }\n        while (low < high) {\n            var mid = Math.floor((low + high) / 2);\n            if (lineOffsets[mid] > offset) {\n                high = mid;\n            }\n            else {\n                low = mid + 1;\n            }\n        }\n        // low is the least x for which the line offset is larger than the current offset\n        // or array.length if no line offset is larger than the current offset\n        var line = low - 1;\n        return { line: line, character: offset - lineOffsets[line] };\n    };\n    FullTextDocument.prototype.offsetAt = function (position) {\n        var lineOffsets = this.getLineOffsets();\n        if (position.line >= lineOffsets.length) {\n            return this._content.length;\n        }\n        else if (position.line < 0) {\n            return 0;\n        }\n        var lineOffset = lineOffsets[position.line];\n        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\n    };\n    Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\n        get: function () {\n            return this.getLineOffsets().length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    FullTextDocument.isIncremental = function (event) {\n        var candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range !== undefined &&\n            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');\n    };\n    FullTextDocument.isFull = function (event) {\n        var candidate = event;\n        return candidate !== undefined && candidate !== null &&\n            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;\n    };\n    return FullTextDocument;\n}());\nexport var TextDocument;\n(function (TextDocument) {\n    /**\n     * Creates a new text document.\n     *\n     * @param uri The document's uri.\n     * @param languageId  The document's language Id.\n     * @param version The document's initial version number.\n     * @param content The document's content.\n     */\n    function create(uri, languageId, version, content) {\n        return new FullTextDocument(uri, languageId, version, content);\n    }\n    TextDocument.create = create;\n    /**\n     * Updates a TextDocument by modifying its content.\n     *\n     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.\n     * @param changes the changes to apply to the document.\n     * @param version the changes version for the document.\n     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.\n     *\n     */\n    function update(document, changes, version) {\n        if (document instanceof FullTextDocument) {\n            document.update(changes, version);\n            return document;\n        }\n        else {\n            throw new Error('TextDocument.update: document must be created by TextDocument.create');\n        }\n    }\n    TextDocument.update = update;\n    function applyEdits(document, edits) {\n        var text = document.getText();\n        var sortedEdits = mergeSort(edits.map(getWellformedEdit), function (a, b) {\n            var diff = a.range.start.line - b.range.start.line;\n            if (diff === 0) {\n                return a.range.start.character - b.range.start.character;\n            }\n            return diff;\n        });\n        var lastModifiedOffset = 0;\n        var spans = [];\n        for (var _i = 0, sortedEdits_1 = sortedEdits; _i < sortedEdits_1.length; _i++) {\n            var e = sortedEdits_1[_i];\n            var startOffset = document.offsetAt(e.range.start);\n            if (startOffset < lastModifiedOffset) {\n                throw new Error('Overlapping edit');\n            }\n            else if (startOffset > lastModifiedOffset) {\n                spans.push(text.substring(lastModifiedOffset, startOffset));\n            }\n            if (e.newText.length) {\n                spans.push(e.newText);\n            }\n            lastModifiedOffset = document.offsetAt(e.range.end);\n        }\n        spans.push(text.substr(lastModifiedOffset));\n        return spans.join('');\n    }\n    TextDocument.applyEdits = applyEdits;\n})(TextDocument || (TextDocument = {}));\nfunction mergeSort(data, compare) {\n    if (data.length <= 1) {\n        // sorted\n        return data;\n    }\n    var p = (data.length / 2) | 0;\n    var left = data.slice(0, p);\n    var right = data.slice(p);\n    mergeSort(left, compare);\n    mergeSort(right, compare);\n    var leftIdx = 0;\n    var rightIdx = 0;\n    var i = 0;\n    while (leftIdx < left.length && rightIdx < right.length) {\n        var ret = compare(left[leftIdx], right[rightIdx]);\n        if (ret <= 0) {\n            // smaller_equal -> take left to preserve order\n            data[i++] = left[leftIdx++];\n        }\n        else {\n            // greater -> take right\n            data[i++] = right[rightIdx++];\n        }\n    }\n    while (leftIdx < left.length) {\n        data[i++] = left[leftIdx++];\n    }\n    while (rightIdx < right.length) {\n        data[i++] = right[rightIdx++];\n    }\n    return data;\n}\nfunction computeLineOffsets(text, isAtLineStart, textOffset) {\n    if (textOffset === void 0) { textOffset = 0; }\n    var result = isAtLineStart ? [textOffset] : [];\n    for (var i = 0; i < text.length; i++) {\n        var ch = text.charCodeAt(i);\n        if (ch === 13 /* CharCode.CarriageReturn */ || ch === 10 /* CharCode.LineFeed */) {\n            if (ch === 13 /* CharCode.CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                i++;\n            }\n            result.push(textOffset + i + 1);\n        }\n    }\n    return result;\n}\nfunction getWellformedRange(range) {\n    var start = range.start;\n    var end = range.end;\n    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {\n        return { start: end, end: start };\n    }\n    return range;\n}\nfunction getWellformedEdit(textEdit) {\n    var range = getWellformedRange(textEdit.range);\n    if (range !== textEdit.range) {\n        return { newText: textEdit.newText, range: range };\n    }\n    return textEdit;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(6086);\n"],"names":["root","factory","exports","module","define","amd","a","i","self","name","objectTypes","freeExports","nodeType","freeModule","freeGlobal","g","moduleExports","global","window","this","input","options","length","features","encodingMode","version","defaultOptions","wait","comments","scope","locations","ranges","onCreateNode","onCreateScope","onDestroyScope","onLocalDeclaration","luaVersion","encodeUTF8","codepoint","highMask","String","fromCharCode","checkChars","rx","s","m","exec","raise","errors","invalidCodeUnit","num","digits","result","toString","toHex","charCodeAt","toUpperCase","encodingModes","fixup","encodeByte","value","discardStrings","Punctuator","NilLiteral","VarargLiteral","tokenTypes","EOF","StringLiteral","Keyword","Identifier","NumericLiteral","BooleanLiteral","unexpected","unexpectedEOF","expected","expectedToken","unfinishedString","malformedNumber","decimalEscapeTooLarge","invalidEscape","hexadecimalDigitExpected","braceExpected","tooLargeCodepoint","unfinishedLongString","unfinishedLongComment","ambiguousSyntax","noLoopToBreak","labelAlreadyDefined","labelNotVisible","gotoJumpInLocalScope","cannotUseVararg","ast","labelStatement","label","type","breakStatement","gotoStatement","returnStatement","args","ifStatement","clauses","ifClause","condition","body","elseifClause","elseClause","whileStatement","doStatement","repeatStatement","localStatement","variables","init","assignmentStatement","callStatement","expression","functionStatement","identifier","parameters","isLocal","forNumericStatement","variable","start","end","step","forGenericStatement","iterators","chunk","literal","raw","tableKey","key","tableKeyString","tableValue","tableConstructorExpression","fields","binaryExpression","operator","left","right","unaryExpression","argument","memberExpression","base","indexer","indexExpression","index","callExpression","tableCallExpression","stringCallExpression","comment","finishNode","node","trackLocations","location","pop","complete","bless","slice","Array","prototype","indexOf","Object","array","element","sprintf","format","call","arguments","replace","match","token","previousToken","lookahead","tokenStart","line","lineStart","scopes","scopeDepth","globals","assign","dest","src","prop","hasOwnProperty","fixupError","e","create","column","error","col","message","apply","SyntaxError","range","tokenValue","raiseUnexpectedToken","found","near","lex","skipWhiteSpace","scanComment","beginLine","beginLineStart","string","charCode","next","extendedIdentifiers","isIdentifierStart","isIdentifierPart","id","labels","contextualGoto","isKeyword","scanIdentifierOrKeyword","delimiter","stringStart","isLineTerminator","beforeEscape","escapeValue","readEscapeSequence","lastLine","lastLineStart","scanStringLiteral","scanNumericLiteral","isDecDigit","scanPunctuator","bitwiseOperators","readLongString","integerDivision","charAt","consumeEOL","peekCharCode","character","digit","fractionStart","exponentStart","digitStart","fraction","binaryExponent","binarySign","isHexDigit","parseInt","foundFraction","Math","pow","foundBinaryExponent","hasFractionPart","readHexLiteral","foundExponent","parseFloat","readDecLiteral","foundImaginaryUnit","imaginaryNumbers","readImaginaryUnitSuffix","integerSuffixes","readInt64Suffix","sequenceStart","frag","ddd","skipWhitespaceEscape","hexEscapes","unicodeEscapes","escStart","b","readUnicodeEscapeSequence","strictEscapes","content","isLong","commentStart","lineStartComment","lineComment","loc","push","isComment","level","terminator","firstLine","consume","expect","isBlockFollow","createScope","destroyScope","scopeIdentifierName","scopeIdentifier","attachScope","property","indexOfObject","scopeHasName","createLocationMarker","Marker","markLocation","pushLocation","marker","FullFlowContext","pendingGotos","LoopFlowContext","loopLevels","makeFlowContext","parseBlock","flowContext","statement","block","relaxedBreak","parseStatement","nameToken","parseIdentifier","addLabel","parseLabelStatement","emptyStatement","raiseDeferredErrors","declToken","addLocal","parseExpectedExpression","l","parseFunctionDeclaration","parseLocalStatement","pushScope","popScope","parseIfStatement","expressions","parseExpression","parseReturnStatement","parseFunctionName","parseWhileStatement","parseForStatement","parseRepeatStatement","isInLoop","parseDoStatement","parseGotoStatement","startMarker","lvalue","targets","both","parsePrefixExpressionPart","values","parseAssignmentOrCallStatement","gotoToken","addGoto","parameter","allowVararg","parsePrimaryExpression","parseTableConstructor","parseSubExpression","binaryPrecedence","minPrecedence","precedence","isUnary","newBase","parsePrefixExpression","parseCallExpression","table","isLoop","locals","deferredGotos","theGoto","maxDepth","target","localCounts","currentScope","newGotos","localCount","bads","levels","levlen","Error","parse","_input","_options","undefined","versionFeatures","write","substr","parseChunk","mode","documents","globalOptions","addDocument","document","uri","TextDocument","languageId","text","getDocument","removeDocument","getDocumentValue","getText","setValue","setGlobalOptions","setOptions","sessionID","merge","mergeObjects","getOption","optionName","applyDeltas","deltas","update","async","position","item","LuaService","BaseService","$service","constructor","super","lua","severity","obj1","obj2","mergedObjects","keys","isArray","concat","__spreadArray","to","from","pack","ar","FullTextDocument","_uri","_languageId","_version","_content","_lineOffsets","defineProperty","get","enumerable","configurable","offsetAt","substring","changes","_i","changes_1","change","isIncremental","getWellformedRange","startOffset","endOffset","startLine","max","endLine","lineOffsets","addedLineOffsets","computeLineOffsets","len","splice","diff","isFull","getLineOffsets","positionAt","offset","min","low","high","mid","floor","lineOffset","nextLineOffset","event","candidate","rangeLength","mergeSort","data","compare","p","leftIdx","rightIdx","ret","isAtLineStart","textOffset","ch","getWellformedEdit","textEdit","newText","applyEdits","edits","lastModifiedOffset","spans","sortedEdits_1","map","join","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","loaded","__webpack_modules__","d","definition","o","globalThis","Function","obj","r","Symbol","toStringTag","nmd","paths","children"],"sourceRoot":""}